#!/bin/sh
#
# Copyright (C) 2020 Simon Byrne, MosÃ¨ Giordano
# License is MIT "Expat"
#
### Commentary:
#
# Command line utility to call the `mpiexec` binary used by the `MPI.jl` version
# in the given Julia project.  It has the same syntax as the `mpiexec` binary
# that would be called, with the additional `--project=...` flag to select a
# different Julia project.
#
# Examples of usage (the MPI flags available depend on the MPI implementation
# called):
#
#   $ mpiexecjl --version
#   $ mpiexecjl -n 40 julia mpi-script.jl
#   $ mpiexecjl --project=my_experiment -n 80 --oversubscribe julia mpi-script.jl
#
### Code:

usage () {
    echo "Usage: ${0} [--project=...] MPIEXEC_ARGUMENTS..."
    echo "Call the mpiexec binary in the Julia environment specified by the --project option."
    echo "If no project is specified, the MPI associated with the global Julia environment will be used."
    echo "All other arguments are forwarded to mpiexec."
}

for arg; do
    shift
    case "${arg}" in
        --project | --project=*)
            PROJECT_ARG="${arg}"
            ;;
        -h | --help)
            usage
            echo "Below is the help of the current mpiexec."
            echo
            set -- "${@}" "${arg}"
            ;;
        *)
            set -- "${@}" "${arg}"
            ;;
    esac
done

if [ -z "${*}" ]; then
    echo "ERROR: no arguments specified." 1>&2
    echo
    usage
    exit 1
fi

if [ -n "${JULIA_BINDIR}" ]; then
    JULIA_CMD="${JULIA_BINDIR}/julia"
else
    JULIA_CMD="julia"
fi

if [ -z "${MPITRAMPOLINE_LIB}" ]; then
    # Find paths to MPICH_jll

    # Note: This requires that `MPICH_jll` is a dependency of the
    # current project, although it MUST NOT be used (aka imported,
    # loaded). Doing so would have two simultaneously active MPI
    # implementations (both MPItrampoline and MPICH), which would lead
    # to name conflicts and likely segfaults. (There would be two
    # incompatible functions `MPI_Init`.)

    # TODO: Do this only when MPI.jl uses MPItrampoline, although this
    # is harmless otherwise.
    # TODO: Cache this; recalculate this only when MPI.jl is rebuilt.

    # shellcheck disable=SC2016
    SCRIPT='
using MPICH_jll
libmpi = MPICH_jll.get_libmpi_path()
libmpicxx = MPICH_jll.get_libmpicxx_path()
libmpifort = MPICH_jll.get_libmpifort_path()
mpiexec = MPICH_jll.get_mpiexec_path()
libmpiwrapper = "$(MPICH_jll.artifact_dir)/lib/libmpiwrapper.so"
println("export MPITRAMPOLINE_PRELOAD='\''$libmpi:$libmpicxx:$libmpifort'\'';")
println("export MPITRAMPOLINE_MPIEXEC='\''$mpiexec'\'';")
println("export MPITRAMPOLINE_LIB='\''$libmpiwrapper'\'';")
'
    eval $("${JULIA_CMD}" -e "${SCRIPT}")
fi

# shellcheck disable=SC2016
SCRIPT='
using MPI
ENV["JULIA_PROJECT"] = dirname(Base.active_project())
mpiexec(exe -> run(`$exe $ARGS`))
'

if [ -n "${PROJECT_ARG}" ]; then
    "${JULIA_CMD}" "${PROJECT_ARG}" --color=yes --startup-file=no -q --compile=min -O0 -e "${SCRIPT}" -- "${@}"
else
    "${JULIA_CMD}" --color=yes --startup-file=no -q --compile=min -O0 -e "${SCRIPT}" -- "${@}"
fi
